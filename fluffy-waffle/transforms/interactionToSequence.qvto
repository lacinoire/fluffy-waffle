modeltype SEQUENCE uses sequence('http://www.mdsd.gar/sequence');
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');

transformation interactionToSequence(in interaction : UML, out sequences_elem : SEQUENCE);

main() {
	log('Start', interaction);
	USER := 'user';
	interaction.objectsOfKind(Model).map transformModel();
}

property USER : String;	

mapping Model::transformModel() : SEQUENCE::Sequences {
	objects := self.ownedElement[Interaction]->forEach(i) {
		i.ownedElement[Lifeline].map transformLifelineToObject(result)
	};
	states := self.ownedElement[Interaction]->forEach(i) {
		i.ownedElement[StateInvariant].map transformStateInvariant(result);
	};
	operations := self.ownedElement[Interaction]->forEach(i) {
		i.ownedElement[MessageOccurrenceSpecification]
			->select(mos : MessageOccurrenceSpecification | mos.message.sendEvent = mos)
			->collect(mos : MessageOccurrenceSpecification | mos.message)
			->select(m : Message | m.messageSort = MessageSort::synchCall)
			.map transformMessageToOperation(result);
	};
	sequences := self.map transformModelToSequence();
}

mapping Model::transformModelToSequence() : SEQUENCE::Sequence {
	init {
		result := self.ownedElement[Interaction]->any(true).map transformInteraction();
	}
}

mapping Interaction::transformInteraction() : SEQUENCE::Sequence {
	// fragment ist das einzige geordnete hier :)
	// uuuuund da sind keine Messages drin T_T
	// aber occurenceEvents... also holen wir uns darÃ¼ber die messages ^^
	var messages := self.fragment[MessageOccurrenceSpecification]
		->select(mos : MessageOccurrenceSpecification | mos.message.sendEvent = mos)
		->collect(mos : MessageOccurrenceSpecification | mos.message)
		->select(m : Message | m.messageSort = MessageSort::synchCall);
	communications += messages.map transformSynchCallMessage(self);

	// iterate throuh state invariants & messages to determine states
	var currentState : StateInvariant;
	var lastSystemCommunication : SystemCommunication;
	self.fragment->forEach(intf) {
		if (intf.oclIsTypeOf(StateInvariant)) {
			currentState := intf.oclAsType(StateInvariant);
			// set as post state for last communication if still necessary
			if (lastSystemCommunication.post_state_rcv = null) {
				lastSystemCommunication.post_state_rcv :=
					currentState.resolveoneIn(StateInvariant::transformStateInvariant);
			}
		} else if (intf.oclIsTypeOf(BehaviorExecutionSpecification)) {
			var message := intf.oclAsType(BehaviorExecutionSpecification).start
				.oclAsType(MessageOccurrenceSpecification).message;
			// did we map this message to a communication?
			if (messages->includes(message)) {
				var communication := message.resolveoneIn(Message::transformSynchCallMessage);
				// we only have states for System Communications
				if (communication.oclIsTypeOf(SystemCommunication)) {
					communication.oclAsType(SystemCommunication).pre_state_rcv :=
						currentState.resolveoneIn(StateInvariant::transformStateInvariant);
					lastSystemCommunication := communication.oclAsType(SystemCommunication);
				};
			}
		}
	};
}

mapping Lifeline::transformLifelineToObject(in result_sequences_elem : Sequences)
	: SEQUENCE::Object {
	init {
		result := result_sequences_elem.objects
			->any(s : Object | s.name = self.name);
		if (result = null) {
			if (self.name = USER) {
				result := object UserObject {}
			} else {
				result := object SystemObject {}
			}
		}
	}
	name := self.name;
}

mapping Message::transformMessageToOperation(in result_sequences_elem : Sequences)
	: SEQUENCE::Operation {
	init {
		result := result_sequences_elem.operations
			->any(s : Operation | s.name = self.name);
		if (result = null) {
			result.name := self.name;
		}
	}
}

mapping StateInvariant::transformStateInvariant(in result_sequences_elem : Sequences)
	: SEQUENCE::State {
	init {
		var name := self.name.substringBefore("_");
		if (name = "" or name = null) {
			name := self.name;
		};
		result := result_sequences_elem.states
			->any(s : State | s.name = name);
		if (result = null) {
			result.name := name;
		}
	}
}

mapping Message::transformSynchCallMessage(in interaction_input : Interaction)
	: SEQUENCE::Communication {
	init {
	// WARUM hier covered ein Bag T_T
		if (self.receiveEvent.oclAsType(MessageOccurrenceSpecification).covered
			->any(true).name = USER) {
				result := object UserCommunication {};
		} else {
			result := object SystemCommunication {};
		}
	}
	operation := self.resolveoneIn(Message::transformMessageToOperation);
	
	// sender
	sender := self.sendEvent.oclAsType(MessageOccurrenceSpecification).covered
		->any(true).resolveoneIn(Lifeline::transformLifelineToObject, Object);
	
	// Return
	return_type := self.findMessageReturnType();
	
	if (result.oclIsTypeOf(UserCommunication)) {
		// receiver = user
		result.oclAsType(UserCommunication).receiver :=
			self.owner.oclAsType(Interaction).ownedElement[Lifeline]
			->any(l : Lifeline | l.name = USER)
			.resolveoneIn(Lifeline::transformLifelineToObject, Object)
			.oclAsType(UserObject);
	} else {
		// receiver = sysobj
		result.oclAsType(SystemCommunication).receiver :=
			self.receiveEvent.oclAsType(MessageOccurrenceSpecification).covered
			->any(true).resolveoneIn(Lifeline::transformLifelineToObject, Object)
			.oclAsType(SystemObject);
			
		// states are done later in one go
	}
}

helper Message::findMessageReturnType() : SEQUENCE::ReturnType {
	var receiveEvent := self.receiveEvent.oclAsType(MessageOccurrenceSpecification);
	// find the behaviour execution that is started by the receiveEvent
	var behavior := self.owner.ownedElement[BehaviorExecutionSpecification]
		->any(b : BehaviorExecutionSpecification | b.start = receiveEvent);
	if (behavior = null) {
		// This happens for "sync messages used as return messages"
		// these always have the return type void
		return object Void {};
	};
	if (behavior.finish.oclAsType(MessageOccurrenceSpecification).message.messageSort
		= MessageSort::reply) {
		return object Value {
			name := behavior.finish.oclAsType(MessageOccurrenceSpecification).message.name;
		};
	} else {
		return object Void {};
	};
}

	//disjuncts Message::transformMessageToUser,
	//Message::transformMessageToSystem;



//mapping Lifeline::transformLifelineToSequence() : SEQUENCE::Sequence 
//when {
//	// user does not get a own sequence
//	self.name != USER;
//}{
//	// gruppieren nach allen Objekten von einer State Invariant bis zu einer anderen State Invariant
//	var group : Set(Element);
//	var in_group : Boolean;
//	self.coveredBy->forEach (element) {
//		if (element.oclIsTypeOf(StateInvariant)) {
//			if (!in_group) {
//				// am Anfang einer Kommunikation
//			}
//		}
//		
//	}
//}
