modeltype SEQUENCE uses sequence('http://www.mdsd.gar/sequence');
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');

transformation interactionToSequence(in interaction : UML, out sequence : SEQUENCE);

main() {
	log('Start', interaction);
	USER := 'user';
	interaction.objectsOfKind(Model).map transformModel();
}

property USER : String;

mapping Model::transformModel() : SEQUENCE::Sequence {
	init {
		result := self.ownedElement[Interaction]->any(true).map transformInteraction();
	}
}

mapping Interaction::transformInteraction() : SEQUENCE::Sequence {
	objects := self.ownedElement[Lifeline].map transformLifelineToObject();
	states := self.ownedElement[StateInvariant].map transformStateInvariant();
	communications += self.message.map transformSynchCallMessage();
}

mapping Lifeline::transformLifelineToObject() : SEQUENCE::Object {
	init {
		if (self.name = USER) {
			result := object UserObject {}
		} else {
			result := object SystemObject {}
		}
	}
	name := self.name;
}

mapping StateInvariant::transformStateInvariant() : SEQUENCE::State {
	name := self.name;
}

mapping Message::transformSynchCallMessage() : SEQUENCE::Communication {
	init {
	// WARUM hier covered ein Bag T_T
		if (self.receiveEvent.oclAsType(MessageOccurrenceSpecification).covered
			->any(true).name = USER) {
				result := object UserCommunication {};
		} else {
			result := object SystemCommunication {};
		}
	}
	operation := object Operation {
		name := self.name;
	};
	// sender
	sender := self.sendEvent.oclAsType(MessageOccurrenceSpecification).covered
		->any(true).resolveoneIn(Lifeline::transformLifelineToObject, Object);
	
	// Return
	return_type := self.findMessageReturnType();
	
	if (result.oclIsTypeOf(UserCommunication)) {
		// receiver = user
		result.oclAsType(UserCommunication).receiver :=
			self.owner.oclAsType(Interaction).ownedElement[Lifeline]
			->any(l : Lifeline | l.name = USER)
			.resolveoneIn(Lifeline::transformLifelineToObject, Object).oclAsType(UserObject);
	} else {
		// receiver = sysobj
		result.oclAsType(SystemCommunication).receiver :=
			self.sendEvent.oclAsType(MessageOccurrenceSpecification).covered
			->any(true).resolveoneIn(Lifeline::transformLifelineToObject, Object)
			.oclAsType(SystemObject);
			
		// TODO states
	}
}

// soooo das wird spaßig: gehe die lifeline des receive events durch 
// und kucke ob etwas zurück geschickt wird (reply type oder synch type = void?)
helper Message::findMessageReturnType() : SEQUENCE::ReturnType {
	var receiveEvent := self.receiveEvent.oclAsType(MessageOccurrenceSpecification);
	var receivingLifelineEvents : Set(InteractionFragment);
	receivingLifelineEvents := receiveEvent.covered->any(true).oclAsType(Lifeline).coveredBy;
	
	// iterate to the current message
	var afterRecvCurrentMessage := false;
	receivingLifelineEvents->forEach (interactionFragment) {
		if (not afterRecvCurrentMessage) {
			// is it our retrun message?
			if (interactionFragment.oclAsType(MessageOccurrenceSpecification) = receiveEvent) {
				afterRecvCurrentMessage := true;
			}
		} else {
			// check whethe we have a send event
			if (interactionFragment.oclIsTypeOf(MessageOccurrenceSpecification)) {
				var message_occurrence : MessageOccurrenceSpecification 
					:= interactionFragment.oclAsType(MessageOccurrenceSpecification);
				// check whether it is a send event
				if (message_occurrence.message.sendEvent.oclAsType(MessageOccurrenceSpecification)
					 = message_occurrence) {
					// check whether receiver of message is the same lifeline as original sender
					if (message_occurrence.message.receiveEvent
						.oclAsType(MessageOccurrenceSpecification).covered->any(true)
						= self.sendEvent
						.oclAsType(MessageOccurrenceSpecification).covered->any(true)) {
						// differentiate between a sync message call and a return
						if (message_occurrence.message.messageSort = MessageSort::reply) {
							return object Void {};
						} else {
							return object Value {
								name := message_occurrence.message.name;
							}
						}
					}
				}
			} 
		}
	};
	log ('find Message return: no return found');
	return null;
}

	//disjuncts Message::transformMessageToUser,
	//Message::transformMessageToSystem;



//mapping Lifeline::transformLifelineToSequence() : SEQUENCE::Sequence 
//when {
//	// user does not get a own sequence
//	self.name != USER;
//}{
//	// gruppieren nach allen Objekten von einer State Invariant bis zu einer anderen State Invariant
//	var group : Set(Element);
//	var in_group : Boolean;
//	self.coveredBy->forEach (element) {
//		if (element.oclIsTypeOf(StateInvariant)) {
//			if (!in_group) {
//				// am Anfang einer Kommunikation
//			}
//		}
//		
//	}
//}
